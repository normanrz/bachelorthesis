\chapter{Client Application Architecture}\section{Overview}The client application of Project Zoom is a web-based application. It can be run using a HTML5-capable web browser. The client application accesses the server's resources through a HTTP-REST interface. The code is partitioned into several modules. An architectural pattern similar to Model-View-Controller (MVC) is applied.\subsection{MV* pattern family}The Model-View-Controller (MVC) pattern was first introduced to the Smalltalk platform by Reenskaug in 1979 \cite{Reenskaug_1979} and later published by Krasner in 1988 \cite{Krasner_1988}. It was one of the first approaches to separate business and presentation logic code within a software project.\begin{figure}\missingfigure{MVC, MVP, MVVM}\caption[Diagrams of Model-View-Controller, Model-View-Presenter and Model-View-ViewModel]{(a) Model-View-Controller \quad (b) Model-View-Presenter \quad (c) Model-View-ViewModel}\label{fig:MV}\end{figure}A \textbf{Model} is an active representation of the data in the system. It usually encapsulates methods for fetching, persisting and transforming the data. It also emits events upon data changes that controllers and views can listen to. The model itself is ignorant of any particular user interface. A \textbf{View} encapsulates all the code required to display an interface including the data from the model. A \textbf{Controller} is responsible for updating the model when a user manipulates the view. \cite{Krasner_1988} \cite{Gamma_1994}Since its introduction in the 1980's the MVC has mutated to accommodate the modern technologies. The architectural patterns MVC, Model-View-Presenter (MVP) and Model-View-ViewModel (MVVM) are commonly referred to as the MV* pattern family \cite{Osmani_2012}. Because of the separation of business and presentation logic MV* patterns are widely used in the development of web applications \cite{Takata_2012}.Model-View-Presenter (MVP) is derived from MVC to achieve a complete separation between Model and View. Whereas in MVC the view depends on the Model in MVP the View is agnostic to a specific Model and can be reused for different Models. The Presenter replaces the Controller and has the responsibility to connect the interfaces of Model and View. Model-View-ViewModel (MVVM) is based on the concepts of MVP. However, the Presenter is replaced by a ViewModel, which contains a subset of the Model as well as additional state and methods. The ViewModel and the View communicate through data-bindings \footnote{Data-binding is technique where properties of a Model can be assigned to user interface components in a way that changes from either are reflected to the other. \cite{Bent_2004}} and events. Because Model and View are separated the VievModel connects both and contains logic in state change and event handlers.MVP and MVVM are commonly used in scenarios where it is important to have user interface components that are general-purpose and have to be reused in several different interfaces. Such applications are usually enterprise or consumer application with a large number of views. MVC is a more lightweight approach is well suited for applications with a smaller number of views and conceptual tight coupling between presentation and data. \cite{Osmani_2012}The client application of Project Zoom only has a few views, as described in section \ref{sec:design}. The interactive graph (see: use case \ref{uc:1} and \ref{uc:5}) is a very close representation of the respective Model. Also, it has to be custom developed as there are no applicable standard components available. Based on these observations the MVC architecture has been selected for the client application of Project Zoom. Figure \ref{fig:arch} shows the implemented architecture. The shown components are detailed in later sections. \begin{figure}\missingfigure{Architecture diagram}\caption{Architecture diagram}\label{fig:arch}\end{figure}\subsection{Event-driven programming}Users expect computer systems to respond quickly. This is especially true for web applications \cite{Selvidge_1999}. In any case users expect the interface to be non-blocking when the system is performing long running tasks \cite{Nielsen_1990}.  In web applications this is achieved through asynchronous APIs for tasks like requesting data from the server \footnote{XMLHttpRequest, \url{http://www.w3.org/TR/XMLHttpRequest/}} or waiting for user input \footnote{Document Object Model Events, \url{http://www.w3.org/TR/DOM-Level-3-Events/}}.An event-driven system is a popular solution for dealing with asynchronous code execution \cite{Michelson_2006}. Event-driven programming is a concept where components of a system heavily communicate by events. Especially, data changes and user actions are propagated using events. Using an event-driven approach also leads to looser coupling between components. This has the benefits of producing better testable and maintainable code \cite{Faison_2011}. Requesting data from the server (see: use case \ref{uc:4}), waiting for user inputs and listening for data synchronization messages (see: requirement \ref{req:3}) are asynchronous tasks that the Project Zoom client performs. Using an event-driven architecture allows the system to pass data streams efficiently through the system.\subsection{Technology}Because Project Zoom is a web application the client code is limited to using JavaScript as technology for its business logic. The presentation layer is built using the standard HTML\footnote{Hypertext Markup Language, \url{http://www.w3.org/TR/html5/}} and CSS\footnote{Cascading Style Sheets, \url{http://www.w3.org/TR/css-2010/}} technologies. The interactive graph relies on SVG\footnote{Scalable Vector Graphics, \url{http://www.w3.org/TR/SVG/}} because of its unique zooming and hit-test\footnote{Hit-testing is a technique to determine which user interface element intersects with the user's cursor \cite{Foley_1995}.} capabilities. The d3\footnote{Data-Driven Documents, \url{http://d3js.org/}} library is used to manipulate the SVG document.\section{Model}

The Model is the component that is responsible for fetching the data from the server, listening on changes and passing changes back to the server.
\subsection{Representing the data in the client application}

The data is represented through two classes that wrap around the native objects of JavaScript: \texttt{DataItem} and \texttt{DataCollection}. Both classes extend the native objects with getter and setter methods for accessing and mutating the respective properties or items. Using getters and setters is currently a popular technique of tracking changes in the data and emitting corresponding events \todo{citation missing, mabye backbone implementation}. When the \texttt{Object.observe} API \cite{Waldron_2012} becomes available this technique may become obsolete. 

\texttt{DataItem} and \texttt{DataCollection} objects can be used to build a hierarchical tree structure. Property changes of child objects are then propagated to their ancestor objects. Also, nested properties can be accessed through the parent's \texttt{get} method using the JSON PointerÂ \footnote{RFC 6901, JavaScript Object Notation (JSON) Pointer, \url{http://tools.ietf.org/html/rfc6901}} syntax.

\todo{Retrieving data + lazy loading \cite{Fowler_2002}}\subsection{Connecting to the server's REST interface}
The server provides the data through an REST interface. Represential State Transfer (REST) is an architectural style on top of HTTP where resources are accessible through non-mutable URLs and are accessed and manipulated through the HTTP verbs instead of custom URLs. \cite{Fielding_2000} 

The specification of the REST interface for Project Zoom can be found in the Appendix. \todo{REST spec in Appendix}

The client accesses the resources through the browser's XMLHttpRequest \cite{W3C_XHR} API. This technique is commonly referred to as Asynchronous JavaScript and XML (AJAX) \cite{Garrett_2005}. 

Upon module initialization 
\subsection{Synchronizing changes with the server}