\chapter{Client Application Architecture}\section{Overview}The client application of Project Zoom is a web-based application. It can be run using a HTML5-capable web browser. The client application accesses the server's resources through a HTTP-REST interface. The code is partitioned into several modules. An architectural pattern similar to Model-View-Controller (MVC) is applied.\subsection{MV* pattern family}The Model-View-Controller (MVC) pattern was first introduced to the Smalltalk platform by Reenskaug in 1979 \cite{Reenskaug_1979} and later published by Krasner in 1988 \cite{Krasner_1988}. It was one of the first approaches to separate business and presentation logic code within a software project.\begin{figure}
\includegraphics[width=\textwidth]{mvc-mvp-mvvm.pdf}\caption[Diagrams of Model-View-Controller, Model-View-Presenter and Model-View-ViewModel]{(a) Model-View-Controller \quad (b) Model-View-Presenter \quad (c) Model-View-ViewModel}\label{fig:MV}\end{figure}A \textbf{Model} is an active representation of the data in the system. It usually encapsulates methods for fetching, persisting and transforming the data. It also emits events upon data changes that controllers and views can listen to. The model itself is ignorant of any particular user interface. A \textbf{View} encapsulates all the code required to display a user interface with the data from the model. A \textbf{Controller} is responsible for updating the model when a user manipulates the view. \cite{Krasner_1988} \cite{Gamma_1994}Since its introduction in the 1980's the MVC has mutated to accommodate the modern technologies. The architectural patterns MVC, Model-View-Presenter (MVP) and Model-View-ViewModel (MVVM) are commonly referred to as the MV* pattern family \cite{Osmani_2012}. Because of the separation of business and presentation logic MV* patterns are widely used in the development of web applications \cite{Takata_2012}.Model-View-Presenter (MVP) is derived from MVC to achieve a complete separation between Model and View. Whereas in MVC the view depends on the Model in MVP the View is agnostic to a specific Model and can be reused for different Models. The Presenter replaces the Controller and has the responsibility to connect the interfaces of Model and View. Model-View-ViewModel (MVVM) is based on the concepts of MVP. However, the Presenter is replaced by a ViewModel, which contains a subset of the Model as well as additional state and methods. The ViewModel and the View communicate through data-bindings \footnote{Data-binding is technique where properties of a Model can be assigned to user interface components in a way that changes from either are reflected to the other. \cite{Bent_2004}} and events. Because Model and View are separated the VievModel connects both and contains logic in state change and event handlers.MVP and MVVM are commonly used in scenarios where it is important to have user interface components that are general-purpose and have to be reused in several different interfaces. Such applications are usually enterprise or consumer application with a large number of views. MVC is a more lightweight approach is well suited for applications with a smaller number of views and conceptual tight coupling between presentation and data. \cite{Osmani_2012}The client application of Project Zoom only has a few views, as described in section \ref{sec:design}. The interactive graph (see: use case \ref{uc:1} and \ref{uc:5}) is a very close representation of the respective Model. Also, it has to be custom developed as there are no applicable standard components available. Based on these observations the MVC architecture has been selected for the client application of Project Zoom. Figure \ref{fig:arch} shows the implemented architecture. The shown components are detailed in later sections.\begin{figure}\missingfigure{Architecture diagram}\caption{Architecture diagram}\label{fig:arch}\end{figure}\subsection{Event-driven programming}Users expect computer systems to respond quickly. This is especially true for web applications \cite{Selvidge_1999}. In any case users expect the interface to be non-blocking when the system is performing long running tasks \cite{Nielsen_1990}.  In web applications this is achieved through asynchronous APIs for tasks like requesting data from the server \footnote{XMLHttpRequest, \url{http://www.w3.org/TR/XMLHttpRequest/}} or waiting for user input \footnote{Document Object Model Events, \url{http://www.w3.org/TR/DOM-Level-3-Events/}}.An event-driven system is a popular solution for dealing with asynchronous code execution \cite{Michelson_2006}. Event-driven programming is a concept where components of a system heavily communicate by events. Especially, data changes and user actions are propagated using events. Using an event-driven approach also leads to looser coupling between components. This has the benefits of producing better testable and maintainable code \cite{Faison_2011}. Requesting data from the server (see: use case \ref{uc:4}), waiting for user inputs and listening for data synchronization messages (see: requirement \ref{req:3}) are asynchronous tasks that the Project Zoom client performs. Using an event-driven architecture allows the system to pass data streams efficiently through the system.\todo{Observer pattern, Publish/Subscribe pattern + Dispatcher}\subsection{Technology}Because Project Zoom is a web application the client code is limited to using JavaScript\footnote{JavaScript is a scripting language that was designed for use in web browsers and was standarized under the name ECMAScript \url{http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf}.} as technology for its business logic. The presentation layer is built using the standard HTML\footnote{Hypertext Markup Language, \url{http://www.w3.org/TR/html5/}} and CSS\footnote{Cascading Style Sheets, \url{http://www.w3.org/TR/css-2010/}} technologies. The interactive graph relies on SVG\footnote{Scalable Vector Graphics, \url{http://www.w3.org/TR/SVG/}} because of its unique zooming and hit-test\footnote{Hit-testing is a technique to determine which user interface element intersects with the user's cursor \cite{Foley_1995}.} capabilities. The d3\footnote{Data-Driven Documents, \url{http://d3js.org/}} library is used to manipulate the SVG document.\section{Model}The Model is the component that is responsible for fetching the data from the server, listening on changes and passing changes back to the server. This section covers the techniques the client applies to handle the domain data on an abstract level. Bocklisch's thesis describes the actual data model in detail \cite{Bocklisch_2013}.\subsection{Representing the data in the client application}The data is represented through two container classes that wrap around the native objects of JavaScript: \texttt{DataItem} and \texttt{DataCollection}. Both classes extend the native objects with getter and setter methods for accessing and mutating the respective properties or items. Using getters and setters is currently a popular technique of tracking changes in the data and emitting corresponding events \todo{citation missing, mabye backbone implementation}. An alternative approach to container classes would be the \texttt{Object.observe} API \cite{Waldron_2012} which has yet to become standarized.The container classes can be used to build hierarchical tree structures. In such a structure property changes of child objects are then propagated to their ancestor objects. Also, nested properties can be accessed through the parent's \texttt{get} method using the JSON Pointer \footnote{RFC 6901, JavaScript Object Notation (JSON) Pointer, \url{http://tools.ietf.org/html/rfc6901}} syntax.Both container classes provide methods for fetching data from the server. For that they use the XMLHttpRequest \cite{W3C_XHR} API of the browser. This technique is commonly referred to as Asynchronous JavaScript and XML (AJAX) \cite{Garrett_2005}. There is also support for lazy loading \footnote{Lazy loading is a technique where data only is loaded once it is required instead of loading it upon initialization. \cite{Fowler_2002}} of properties or subtrees. When importing a native JavaScript object into an container properties with names starting with an underscore are treated as candidates for lazy loading. It is expected that their initial values contain information how to retrieve the data from the server (e.g. how to build the URL).\subsection{Connecting to the server's REST interface}\begin{figure}\missingfigure{Object diagram}\caption{Illustration of an example domain data structure.}\label{fig:projectstruc}\end{figure}The server provides the data through an REST interface. Representational State Transfer (REST) is an architectural style on top of HTTP where resources are accessible through non-mutable URLs and are accessed and manipulated through the HTTP verbs instead of custom URLs. \cite{Fielding_2000} The REST interface for Project Zoom relies on the JSON \footnote{RFC 4627,  The application/json Media Type for JavaScript Object Notation (JSON), \url{http://tools.ietf.org/html/rfc4627}} format for data exchange. As JSON is based on a subset of JavaScript, is is very easy to parse and create JSON documents through native APIs. The full specification of the REST interface is attached in the Appendix  \ref{appendix:REST}.Upon initialization the Model requests the \texttt{projects} and \texttt{tags} collections from the server. This is useful because all business logic depends on these data collections and lazy loading would extend page loading time. As shown in figure \ref{fig:projectstruc} the projects collection is one of the root data structures in the system. As shown in Appendix \ref{appendix:REST} the request \texttt{GET /projects} yields a list of project objects that doesn't contain all properties in full detail. For example the \texttt{\_graphs} property is a lazy loading canditate that initially holds the IDs of the referenced graphs. The model loads the respective graph objects on-demand.\subsection{Synchronizing changes with the server}Changes to the server are transmitted using the recently introduced JSON Patch standard \cite{RFC6902}. JSON Patch is a format for describing a list of mutations in an existing JSON document. A mutation entry contains an operation identifier, e.g. \texttt{add}, \texttt{remove} or \texttt{replace}, as well as a property address using the JSON Pointer syntax and a new value. Figure \ref{fig:jsonpatch} shows an example of a JSON patch applied to a JSON document.\begin{figure}\begin{lstlisting}[language=json,caption=Initial JSON document]{ "foo": "bar" }\end{lstlisting}\begin{lstlisting}[language=json,caption=JSON patch][  {     "op": "replace", "path": "foo",    "value": {      "baz": "bar"    }  },  { "op": "add", "path": "foo/qux", "value": 123 }]\end{lstlisting}\begin{lstlisting}[language=json,caption=Resulting JSON document]{  "foo": {    "baz": "bar",    "qux": 123  }}\end{lstlisting}\caption{An example JSON patch application}\label{fig:jsonpatch}\end{figure}The JSON patches are generated by the class \texttt{JsonPatchAccumulator}. It connects to a \texttt{DataItem} object and listens to the change events. Because \texttt{DataItem}s propagate change events from their child nodes, the accumulator can be attached to any node and will receive the change events from the complete subtree. For each change the accumulator appends a new patch entry to a list buffer, which will eventually be sent to the server.For some user actions, e.g. dragging an element across the canvas, the amount of patch entries can grow very fast. To minimize the transportation footprint of the patches, the accumulator provides a method for compacting patches by reducing the amount of redundant entries in the patch. The proposed algorithm is shown in figure \ref{fig:patchcompact} and has a time complexity of $\mathcal O(n^2)$. Compacted patches are then sent to the server using the HTTP \texttt{PATCH} method.\begin{figure}\begin{lstlisting}[language=pseudo]foreach patch1, i in patches  if patch1 is marked as overridden    remove patch1    foreach patch2, j in entries where i > j    if patch2 removes the item or any parent of patch1      remove patch1      mark patch2 as overridden          else if patch2 replaces the item of patch1 or any parent of patch1      remove patch2         else if patch2 replaces or removes a child item of patch1      merge patch2 into patch1      mark patch2 as overridden    \end{lstlisting}\caption{Pseudo code for compacting a chronologically ordered list of JSON patches}\label{fig:patchcompact}\end{figure}The client is designed to listen on changes sent from the server. For that the client opens a WebSocket\footnote{WebSocket, \url{http://tools.ietf.org/html/rfc6455}, \url{http://www.w3.org/TR/2009/WD-websockets-20091222/}} connection. The server sends JSON patches with an accompanying resource identifier, which get applied to the data structure in the client. Because of the event-driven architecture of the client, these changes will be propagated to the View immediately. As concurrent users editing a single resource, e.g. graph, is not expected (see: requirement \ref{req:3}, this thesis does not cover concurrency control. This is a well-known problem and there are several proposed solutions published, e.g. Operational Transformation \cite{Ellis_1989}.\section{View}

The View is a set of components that are responsible for rendering the data to the user interface.\subsection{Component interface}

\begin{wrapfigure}{r}{0.3\textwidth}
\includegraphics[width=0.3\textwidth]{viewinterface.pdf}
\caption{Class diagram of the View component interface}
\label{fig:viewinterface}
\end{wrapfigure}

The View is assembled by a hierarchical structure of View component instances. These instances share a common interface as shown in figure \ref{fig:viewinterface}. The view objects are responsible for controlling one element in the Document Object Model (DOM), which is referenced through the attribute \texttt{el}. At this stage the view component is not interactive yet. The method \texttt{activate} enables interactivity, by attaching event handlers to the DOM. \texttt{deactivate} then removes these event handlers, making the view component non-interactive again. This approach allows other components to control which View components are currently active. Consequently, parent components are responsible for activating and deactivation their children. The View components do not attach their element to the DOM themselves.\subsection{Data integration}

Upon initialization View components are assigned with a \texttt{DataItem} or a \texttt{DataCollection}. The contained data is then used to render the user interface. Views tap into the event system and listen on changes from the Model to update accordingly. For example, when a user moves the cursor across the canvas to drag a graph node, the \texttt{position} property of the node is being altered by a controller. This change is propagated to the view, which then renders the node at its new position. Server-sent changes are handled in the very same way. So, the view is agnostic to what the event source is.

\subsection{Architecture}

\begin{figure}\includegraphics[width=\textwidth]{viewlayout.png}\caption[Screenshot of the Process view with component annotations]{Screenshot of the Process view with component annotations: (a) \texttt{ProcessView} \quad (b) \texttt{ArtifactFinder} \quad (c) \texttt{Toolbar} \quad (d) \texttt{Graph}}\label{fig:viewlayout}\end{figure}

There are three main views: Overview view, Details view and Process view (see: section \ref{sec:design}). As shown in figure \ref{fig:arch} these are represented by three hierarchical View component structures. Figure \ref{fig:viewlayout} is an example of how the individual components have distributed responsibilities.

\section{Controller}

The controller components are responsible for handling user interactions and manipulating the data in the Model.\subsection{Main controller}
In the Project Zoom client there is one main controller that handles the zoom-based actions. Based on the current zoom level it attaches or detaches the main view. For that it also manages the global zoom slider view. 

\subsection{Behavior controllers}